---
title: "An MPM with recurrent removal (Hastings _et al._ 2006) - eq. 3"
author: "Bram D'hondt"
date: "2025-12-19"
output: pdf_document
---

```{r setup, include=F}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=F}
library(expm)
library(popdemo)
```

```{r prep matrix display, include=F}
# based on https://data-and-the-world.onrender.com/posts/matrix-to-latex/
array_to_LaTeX <- function(arr){
  rows <- apply(arr, MARGIN=1, paste, collapse = " & ")
  matrix_string <- paste(rows, collapse = " \\\\ ")
  return(paste("$\\begin{bmatrix}", matrix_string, "\\end{bmatrix}$"))
}
# use in combination with chunck settings {r, results='asis'} and cat(array_to_LaTeX(.)) (see below) `
```

# Introduction

$$N_{T} = L^TN_{0}-\sum_{i=1}^{T}L^{T+1-i}H_{i}$$

This is a preparatory document that develops the above formula step by step, using a simple example. This not only serves as an illustration, but it also acts as a reference to check whether the developed function, the scripting of which is way more abstract, is correct.

First, I avoid using _popdemo_ functions, to stay closer to the core formulation. Then, I  provide the _popdemo_ alternative, which is heavily used in further development. Note how the _popdemo::project()_ function has the huge advantage that, for a given time span, all intermediate values are provided. Also, by using the option _return.vec = FALSE/TRUE_, one can switch between output per stage or summed over stages.

As a time span, we opt for five steps (years), i.e. $T = 5$.

# $L$, $N{0}$ and $H$ 

```{r transition matrix L, echo=F}
L <- matrix(c(0, 0.1, 0.1, 
              1, 1.0, 1.0,
              0, 0.3, 1.2),
            nrow = 3,
            byrow = TRUE)

# rownames(L) <- colnames(L) <- c("seedlings",
#                                 "isolates",
#                                 "meadows")
```

$L$ is
```{r, echo=F, results='asis'}
cat(array_to_LaTeX(L))
```


```{r initial vector N0, echo=F}
N0 <- matrix(c(0.1,
               0.1,
               0.1),
             nrow = 3,
             byrow = TRUE)

# rownames(N0) <- rownames(L)
```

$N_0$ is
```{r, echo=F, results='asis'}
cat(array_to_LaTeX(N0))
```

The area removed is $H$. Removal is performed at the **start of the year**. This is important to understand, because for one thing, it means that you will nowhere see the value of $H$ in the 'ghost matrix' (see further); the first value you will encounter directly is $LH$, i.e. the end-of-year 'ghost' of what was newly removed at the start of the year.

$H$ is
```{r removal vector H, echo=F}

H <- matrix(c(0.,
              0.1,
              0),
             nrow = 3,
             byrow = TRUE)

rownames(N0) <- rownames(L)
print(H)
```

# Without removal

If there would be **no removal**, an MPM's base formula gives the population extent.

$$N_{T} = L^TN_{0}$$

Without _popdemo_:
```{r simple projection - without popdemo}

N1 <- sum(L%^%1 %*% N0) # expm package
N2 <- sum(L%^%2 %*% N0) # matrix power (L^2 = element-wise, L%^%2 = L x L)
N3 <- sum(L%^%3 %*% N0)
N4 <- sum(L%^%4 %*% N0)
N5 <- sum(L%^%5 %*% N0)

print(c(sum(N0), N1, N2, N3, N4, N5))
```

With _popdemo_. Note how $N{0}$ is automatically included in the output.
```{r simple projecten - with popdemo}

Nt <- project(L, vector = N0, time = 5, return.vec = T)

print(Nt)        # across stages
print(t(Nt@vec)) # per stage
```

# With removal

Let's now include **removal**. The equation on top states that from this total projection, we now have to substract a contingent of "what could have been", i.e. that which would have resulted from the removed portion ($-L^TH$), for each of the time steps that have passed ($sum_{i=1}^{T}$).

I refer to the removed cohorts and how they would have propagated as 'ghosts', their yearly numbers collected in the *ghost matrix*.

Without _popdemo_:
```{r removal - without popdemo}

total  = sum(L%^%5 %*% N0)         # total (actual + removed) - as above

ghost1 = sum(L%^%(5+1-1) %*% H)    # removed in year 1 (five years ago)
ghost2 = sum(L%^%(5+1-2) %*% H)    # removed in year 2 (four years ago)
ghost3 = sum(L%^%(5+1-3) %*% H)    # removed in year 3 (three years ago)
ghost4 = sum(L%^%(5+1-4) %*% H)    # removed in year 4 (two years ago)
ghost5 = sum(L%^%(5+1-5) %*% H)    # removed in year 5 (previous year)

total-sum(ghost1, ghost2, ghost3, ghost4, ghost5)
```

With _popdemo_:
```{r removal - with popdemo}

total.  = project(L, vector = N0, time = 5, return.vec = F)
ghost.1 = project(L, vector = H,  time = 5+1-1, return.vec = F) # removed in year 1 (five years ago)
ghost.2 = project(L, vector = H,  time = 5+1-2, return.vec = F) # removed in year 2 (four years ago)
ghost.3 = project(L, vector = H,  time = 5+1-3, return.vec = F) # removed in year 3 (three years ago)
ghost.4 = project(L, vector = H,  time = 5+1-4, return.vec = F) # removed in year 4 (two years ago)
ghost.5 = project(L, vector = H,  time = 5+1-5, return.vec = F) # removed in year 5 (previous year)

tail(total.,1)-(tail(ghost.1,1)+tail(ghost.2,1)+tail(ghost.3,1)+tail(ghost.4,1)+tail(ghost.5,1))
```

This now opens the way to the generic formulation, in the next script (2_eq3_...).